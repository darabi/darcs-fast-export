#!/usr/bin/env python

"""

    darcs-fast-export - darcs backend for fast data exporters

    Copyright (c) 2008 Miklos Vajna <vmiklos@frugalware.org>

    This program is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation; either version 2, or (at your option)
    any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program; if not, write to the Free Software
    Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.

"""

import sys
import os
import time

class Handler:
	def __init__(self):
		self.marks = {}
		self.files = []
		self.ch = None

	def readline(self):
		buf = ""
		if self.ch:
			buf += self.ch
			self.ch = None
		buf += sys.stdin.readline()
		return buf

	def read(self, length):
		buf = ""
		if self.ch:
			buf += self.ch
			self.ch = None
		buf += sys.stdin.read(length)
		return buf

	def skip_optional_lf(self):
		self.ch = sys.stdin.read(1)
		if self.ch == "\n":
			self.ch = None

	def bug(self, s):
		raise Exception(s)

	def get_date(self, ts, tz):
		s = time.strftime("%a %b %d %H:%M:%S %Y", time.gmtime(int(ts)))
		items = s.split(' ')
		return " ".join(items[:-1]) + " " + tz + " " + items[-1]

	def handle_blob(self):
		while True:
			line = self.readline().strip()
			if line.startswith("mark :"):
				num = int(line[6:])
			elif line.startswith("data "):
				length = int(line[5:])
				self.marks[num] = self.read(length)
				return
			else:
				self.bug("'%s': invalid blob subcommand" % line)

	def handle_commit(self):
		adds = []
		author = None
		while True:
			line = self.readline().strip()
			if line.startswith("mark :"):
				pass
			elif line.startswith("author "):
				items = line[7:].split(' ')
				author = " ".join(items[:-2])
				date = self.get_date(items[-2], items[-1])
			elif line.startswith("committer "):
				if author:
					continue
				items = line[10:].split(' ')
				author = " ".join(items[:-2])
				date = self.get_date(items[-2], items[-1])
			elif line.startswith("data "):
				length = int(line[5:])
				msg = self.read(length)
				self.skip_optional_lf()
				items = msg.split('\n')
				short = items[0]
				long = "\n".join(items[1:])
			elif line.startswith("M "):
				items = line.split(' ')
				idx = int(items[2][1:])
				path = items[3]
				sock = open(path, "w")
				sock.write(self.marks[idx])
				sock.close()
				if path not in self.files:
					adds.append(path)
					self.files.append(path)
				del self.marks[idx]
			elif line.startswith("D "):
				path = line[2:]
				os.unlink(path)
				self.files.remove(path)
			elif line.startswith("from "):
				pass
			elif line.startswith("merge "):
				pass
			elif not len(line):
				for i in adds:
					os.system("darcs add %s" % i)
				sock = os.popen("darcs record --ignore-times -a --pipe", "w")
				buf = [date, author, short, long]
				sock.write("\n".join(buf))
				sock.close()
				return
			else:
				self.bug("'%s': invalid commit subcommand" % line)

	def handle_progress(self, s):
		print "progress [%s] %s" % (time.strftime("%Y-%m-%d %H:%M:%S", time.localtime()), s)
		sys.stdout.flush()

	def handle(self):
		while True:
			line = self.readline()
			if not line:
				break
			line = line.strip()
			if not len(line):
				continue
			if line == "blob":
				self.handle_blob()
			elif line.startswith("reset"):
				pass
			elif line.startswith("commit"):
				self.handle_commit()
			elif line.startswith("progress"):
				self.handle_progress(line[9:])
			else:
				self.bug("'%s': invalid command" % line)

if __name__ == "__main__":
	h = Handler()
	h.handle()
