#!/usr/bin/env python

"""

    darcs-fast-export - darcs backend for fast data exporters

    Copyright (c) 2008 Miklos Vajna <vmiklos@frugalware.org>

    This program is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation; either version 2, or (at your option)
    any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program; if not, write to the Free Software
    Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.

"""

import sys
import os
import time

class Handler:
	def __init__(self):
		self.marks = {}
		self.files = []
		self.ch = None
		self.line = None
		self.unread_line = False
		self.eof = False
		self.debug = False

	def read_next_line(self):
		if self.unread_line:
			self.unread_line = False
			return
		self.line = ""
		if self.eof:
			return
		if self.ch:
			self.line += self.ch
			self.ch = None
		buf = sys.stdin.readline()
		if not len(buf):
			self.eof = True
		else:
			self.line += buf
		if self.debug:
			print "read_next_line: '%s'" % self.line

	def read(self, length):
		buf = ""
		if self.ch:
			buf += self.ch
			self.ch = None
		buf += sys.stdin.read(length)
		if self.debug:
			print "read: '%s'" % buf
		return buf

	def skip_optional_lf(self):
		self.ch = self.read(1)
		if self.ch == "\n":
			self.ch = None

	def bug(self, s):
		raise Exception(s)

	def get_date(self, ts, tz):
		s = time.strftime("%a %b %d %H:%M:%S %Y", time.gmtime(int(ts)))
		items = s.split(' ')
		return " ".join(items[:-1]) + " " + tz + " " + items[-1]

	def handle_mark(self):
		if self.line.startswith("mark :"):
			self.mark_num = int(self.line[6:-1])
			self.read_next_line()

	def handle_data(self):
		if not self.line.startswith("data "):
			self.bug("Expected 'data n' command, found: '%s'" % self.line[:-1])
		length = int(self.line[5:-1])
		self.buf = self.read(length)
		self.skip_optional_lf()

	def handle_blob(self):
		self.read_next_line()
		self.handle_mark()
		self.handle_data()
		self.marks[self.mark_num] = self.buf

	def handle_ident(self, s):
		items = s.split(' ')
		self.ident = " ".join(items[:-2])
		self.date = self.get_date(items[-2], items[-1])

	def handle_msg(self):
		items = self.buf.split('\n')
		self.short = items[0]
		self.long = "\n".join(items[1:])

	def handle_tag(self):
		version = self.line[:-1].split(' ')[1]
		self.read_next_line()
		if self.line.startswith("from "):
			self.read_next_line()
		if self.line.startswith("tagger "):
			self.handle_ident(self.line[7:-1])
			self.read_next_line()
		self.handle_data()
		self.skip_optional_lf()
		sock = os.popen("darcs tag --pipe", "w")
		buf = [self.date, self.ident, version]
		sock.write("\n".join(buf))
		sock.close()

	def handle_commit(self):
		self.prevfiles = self.files[:]
		adds = []

		self.read_next_line()
		self.handle_mark()
		if self.line.startswith("author "):
			self.handle_ident(self.line[7:-1])
			self.read_next_line()
		if self.line.startswith("committer "):
			self.handle_ident(self.line[10:-1])
			self.read_next_line()
		self.handle_data()
		self.skip_optional_lf()
		self.handle_msg()
		self.read_next_line()
		if self.line.startswith("from "):
			self.read_next_line()
		while self.line.startswith("merge "):
			self.read_next_line()
		while len(self.line) > 0:
			if self.line.startswith("M "):
				items = self.line.split(' ')
				path = items[3][:-1]
				sock = open(path, "w")
				if items[2] != "inline":
					idx = int(items[2][1:])
					sock.write(self.marks[idx])
					del self.marks[idx]
				else:
					self.read_next_line()
					self.handle_data()
					sock.write(self.buf)
				sock.close()
				if path not in self.prevfiles:
					adds.append(path)
				if path not in self.files:
					self.files.append(path)
			elif self.line.startswith("D "):
				path = self.line[2:-1]
				os.unlink(path)
				if path in self.files:
					self.files.remove(path)
			else:
				self.unread_line = True
				break
			self.read_next_line()
			if not len(self.line):
				break

		for i in adds:
			os.system("darcs add %s" % i)
		sock = os.popen("darcs record --ignore-times -a --pipe", "w")
		buf = [self.date, self.ident, self.short, self.long]
		sock.write("\n".join(buf))
		sock.close()

	def handle_progress(self, s):
		print "progress [%s] %s" % (time.strftime("%Y-%m-%d %H:%M:%S", time.localtime()), s.strip())
		sys.stdout.flush()

	def handle(self):
		while not self.eof:
			self.read_next_line()
			if not len(self.line[:-1]):
				pass
			elif self.line.startswith("blob"):
				self.handle_blob()
			elif self.line.startswith("reset"):
				pass
			elif self.line.startswith("commit"):
				self.handle_commit()
			elif self.line.startswith("tag"):
				self.handle_tag()
			elif self.line.startswith("progress"):
				self.handle_progress(self.line[9:])
			else:
				self.bug("'%s': invalid command" % self.line[:-1])

if __name__ == "__main__":
	h = Handler()
	h.handle()
